{"version":3,"sources":["scripts/resolvers/resolver.js"],"names":[],"mappings":";;;;;;;;;;;;;;sBAIiD,WAAW;;;;;;;;;;;;;;;;;;;;;IAoBvC,QAAQ;;;;;;;;AAOhB,WAPQ,QAAQ,CAOf,QAAQ,EAAE;0BAPH,QAAQ;;AAQzB,QAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;GAC1B;;;;;;;;;;;;eATkB,QAAQ;;WAoBnB,kBAAC,IAAI,EAAE,GAAG,EAAgB;UAAd,OAAO,yDAAG,EAAE;;AAC9B,UAAI,IAAI,GAAG,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;AAC7B,UAAI,IAAI,GAAG,OAAO,CAAC,IAAI,oBAAY,CAAC;AACpC,UAAI,SAAS,GAAG,OAAO,CAAC,SAAS,qBAAa,CAAC;AAC/C,UAAI,IAAI,EAAE;AACR,gBAAQ,IAAI;AACV;AAAW;AACT,kBAAI,CAAC,QAAQ,CAAC,YAAY,CAAC,IAAI,EAAE,GAAG,EAAE,IAAI,EAAE,SAAS,CAAC,CAAC;AACvD,oBAAM;aACP;;AAAA,AAED;AAAc;AACZ,kBAAI,CAAC,QAAQ,CAAC,eAAe,CAAC,IAAI,EAAE,GAAG,EAAE,IAAI,EAAE,SAAS,CAAC,CAAC;AAC1D,oBAAM;aACP;;AAAA,AAED;AAAe;AACb,kBAAI,CAAC,QAAQ,CAAC,gBAAgB,CAAC,IAAI,EAAE,GAAG,EAAE,IAAI,EAAE,SAAS,CAAC,CAAC;AAC3D,oBAAM;aACP;;AAAA,AAED;AACE,oCAAsB,IAAI,CAAI;;AAAA,SAEjC;OACF;KACF;;;;;;;;;;WAQM,iBAAC,GAAG,EAAE;AACX,YAAM,uBAAuB,CAAC;KAC/B;;;SAxDkB,QAAQ;;;qBAAR,QAAQ","file":"resolver.js","sourcesContent":["/**\n * Created by dmitriy.ryajov on 7/17/15.\n */\n\nimport {TYPE, FACTORY, INSTANCE, SINGLETON} from '../consts';\n\n/**\n * A resolver is an abstract helper class that allows specifying your own wiring logic.\n * For example, you might want to have a JSON or an XML document describe how dependencies\n * are wired, and bypass the programmatic API altogether.\n *\n * There are two phases, register and resolve.\n *\n * By default, register maps a register* method to a type of dependency.\n * The dependency types are - TYPE, FACTORY, INSTANCE and are looked up in the option's object type\n * property that is passed to register. Register will call resolve just before performing\n * registration of the dependency, and it expects an array of dependency names to be returned by it.\n *\n * This model should be flexible enough to allow writing resolvers for different needs ans scenarios.\n * The api has been intentionally left open to allow extensibility, and cater to as many different needs\n * as possible. However, this is not considered a core part of the framework, and is provided for convenience\n * mostly. Consider defining your own set of resolvers if this does not fit into your existing model, or using\n * the programmatic API directly.\n */\nexport default class Resolver {\n\n  /**\n   * Construct a resolver\n   *\n   * @param injector - an instance of opium-ioc compatible object\n   */\n  constructor(injector) {\n    this.injector = injector;\n  }\n\n  /**\n   * Register a dependency\n   *\n   * @param name - dependency name\n   * @param dep - the dependency to be registered\n   * @param options - options object, by default expects type=[TYPE|FACTORY|INSTANCE]\n   *                  and lifecycle=[SINGLETON|PROTOTYPE] to be defined. Both are defaulted\n   *                  to INSTANCE and SINGLETON respectively.\n   */\n  register(name, dep, options = {}) {\n    let deps = this.resolve(dep);\n    let type = options.type || INSTANCE;\n    let lifecycle = options.lifecycle || SINGLETON;\n    if (deps) {\n      switch (type) {\n        case TYPE: {\n          this.injector.registerType(name, dep, deps, lifecycle);\n          break;\n        }\n\n        case FACTORY: {\n          this.injector.registerFactory(name, dep, deps, lifecycle);\n          break;\n        }\n\n        case INSTANCE: {\n          this.injector.registerInstance(name, dep, deps, lifecycle);\n          break;\n        }\n\n        default:\n          throw(`Unknown type ${type}`);\n\n      }\n    }\n  }\n\n  /**\n   * Resolve dependency names from the passed in dependency. By default, its called\n   * right before registering a dependency by the register method.\n   *\n   * @param dep\n   */\n  resolve(dep) {\n    throw 'method unimplemented!';\n  }\n}\n"]}