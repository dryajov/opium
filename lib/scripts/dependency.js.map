{"version":3,"sources":["scripts/dependency.js"],"names":[],"mappings":";;;;;;;;;;;;;;sBAImC,UAAU;;;;;;;;;IAQxB,UAAU;;;;;;;;;;;;;;AAalB,WAbQ,UAAU,CAajB,IAAI,EAAE,GAAG,EAAE,IAAI,EAAE,QAAQ,EAAE,QAAQ,EAAE,SAAS,EAAE,IAAI,EAAE;;;0BAb/C,UAAU;;AAc3B,QAAI,CAAC,IAAI,GAAG,IAAI,CAAC;AACjB,QAAI,CAAC,GAAG,GAAG,GAAG,CAAC;AACf,QAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;AACzB,QAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;AACzB,QAAI,CAAC,SAAS,GAAG,SAAS,CAAC;AAC3B,QAAI,CAAC,IAAI,GAAG,IAAI,CAAC;;AAEjB,QAAI,CAAC,IAAI,GAAG,IAAI,CAAC;AACjB,QAAI,CAAC,QAAQ,GAAG,IAAI,CAAC;AACrB,QAAI,CAAC,WAAW,GAAG,KAAK,CAAC;;AAEzB,QAAI,IAAI,CAAC,IAAI,IAAI,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,UAAC,OAAO,EAAK;AAC3C,aAAO,MAAK,IAAI,KAAK,OAAO,CAAA;KAC7B,CAAC,CAAC,MAAM,EAAE;AACX,YAAM,IAAI,KAAK,oBAAiB,IAAI,CAAC,IAAI,cAAS,IAAI,CAAC,IAAI,CAAG,CAAC;KAChE;GACF;;;;;;;;eA9BkB,UAAU;;WAqCvB,kBAAG;AACP,UAAI,CAAC,IAAI,CAAC,WAAW,IAAI,IAAI,CAAC,SAAS,sBAAc,EAAE;AACrD,YAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;AAC3C,YAAI,CAAC,WAAW,GAAG,IAAI,CAAC;OACzB;;AAED,aAAO,IAAI,CAAC,QAAQ,CAAC;KACtB;;;;;;;;;WAOM,mBAAG;AACR,UAAI,YAAY,GAAG,EAAE,CAAC;AACtB,UAAI,IAAI,CAAC,IAAI,EAAE;;;;;;AACb,+BAAiB,IAAI,CAAC,IAAI,8HAAE;gBAAnB,KAAI;;AACX,wBAAY,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,KAAI,CAAC,CAAC,CAAC;WAC5C;;;;;;;;;;;;;;;OACF;;AAED,aAAO,YAAY,CAAC;KACrB;;;SA5DkB,UAAU;;;qBAAV,UAAU","file":"dependency.js","sourcesContent":["/**\n * Created by dmitriy.ryajov on 6/14/15.\n */\n\nimport {SINGLETON, PROTOTYPE} from './consts';\n\n/**\n * A Dependency wraps any real dependency (thingy) and provides the facilities\n * require to perform DI on it. Whenever one of the register* methods is called\n * to register a dependency with Opium, it will be wrapped in this object, subsequent\n * calls to the inject method on it, will trigger the injection cycle.\n */\nexport default class Dependency {\n\n  /**\n   * Construct a dependency\n   *\n   * @param name - Name of the dependency\n   * @param dep - The dependency to be wrapped\n   * @param deps - An array of dependency names\n   * @param registry - The global dep registry\n   * @param injector - The injector to be used\n   * @param lifecycle - The lifecycle of the depepndency\n   * @param args - The arguments to pass as is, to constructors and factories\n   */\n  constructor(name, dep, deps, registry, injector, lifecycle, args) {\n    this.name = name;\n    this.dep = dep;\n    this.registry = registry;\n    this.injector = injector;\n    this.lifecycle = lifecycle;\n    this.args = args;\n\n    this.deps = deps;\n    this.injected = null;\n    this.hasInjected = false;\n\n    if (this.deps && this.deps.filter((depName) => {\n        return this.name === depName\n      }).length) {\n      throw new Error(`Can't inject ${this.name} into ${this.name}`);\n    }\n  }\n\n  /**\n   * Perform the injection cycle according to the current dep lifecycle\n   *\n   * @returns {Dependency.injected|*} - Returns the result of performing the injection cycle\n   */\n  inject() {\n    if (!this.hasInjected || this.lifecycle === PROTOTYPE) {\n      this.injected = this.injector.inject(this);\n      this.hasInjected = true;\n    }\n\n    return this.injected;\n  }\n\n  /**\n   * Get an array of dependencies that this Dependency expects\n   *\n   * @returns {Array}\n   */\n  resolve() {\n    let dependencies = [];\n    if (this.deps) {\n      for (let name of this.deps) {\n        dependencies.push(this.registry.get(name));\n      }\n    }\n\n    return dependencies;\n  }\n}\n"]}