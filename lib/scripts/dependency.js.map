{"version":3,"sources":["scripts/dependency.js"],"names":[],"mappings":";;;;;;;;;;;;;;sBAImC,UAAU;;;;;;;;;IAQxB,UAAU;;;;;;;;;;;;;AAYhB,aAZM,UAAU,CAYf,IAAI,EAAE,GAAG,EAAE,IAAI,EAAE,QAAQ,EAAE,QAAQ,EAAE,SAAS,EAAE;;;8BAZ3C,UAAU;;AAavB,YAAI,CAAC,IAAI,GAAG,IAAI,CAAC;AACjB,YAAI,CAAC,GAAG,GAAG,GAAG,CAAC;AACf,YAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;AACzB,YAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;AACzB,YAAI,CAAC,SAAS,GAAG,SAAS,CAAC;;AAE3B,YAAI,CAAC,IAAI,GAAG,IAAI,CAAC;AACjB,YAAI,CAAC,QAAQ,GAAG,IAAI,CAAC;;AAErB,YAAI,IAAI,CAAC,IAAI,IAAI,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,UAAC,OAAO,EAAK;AAAC,mBAAO,MAAK,IAAI,KAAK,OAAO,CAAA;SAAC,CAAC,CAAC,MAAM,EAAE;AACnF,kBAAM,IAAI,KAAK,oBAAiB,IAAI,CAAC,IAAI,cAAS,IAAI,CAAC,IAAI,CAAG,CAAC;SAClE;KACJ;;;;;;;;iBAzBgB,UAAU;;eAgCrB,kBAAG;AACL,gBAAI,CAAC,IAAI,CAAC,QAAQ,IAAI,IAAI,CAAC,SAAS,sBAAc,EAAE;AAChD,oBAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC,GAAG,CAAC;aAC1D;;AAED,mBAAO,IAAI,CAAC,QAAQ,CAAC;SACxB;;;;;;;;;eAOM,mBAAG;AACN,gBAAI,YAAY,GAAG,EAAE,CAAC;AACtB,gBAAI,IAAI,CAAC,IAAI,EAAE;;;;;;AACX,yCAAiB,IAAI,CAAC,IAAI,8HAAE;4BAAnB,KAAI;;AACT,oCAAY,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,KAAI,CAAC,CAAC,CAAC;qBAC9C;;;;;;;;;;;;;;;aACJ;;AAED,mBAAO,YAAY,CAAC;SACvB;;;WAtDgB,UAAU;;;qBAAV,UAAU","file":"scripts/dependency.js","sourcesContent":["/**\n * Created by dmitriy.ryajov on 6/14/15.\n */\n\nimport {SINGLETON, PROTOTYPE} from './consts';\n\n/**\n * A Dependency wraps any real dependency (thingy) and provides the facilities\n * require to perform DI on it. Whenever one of the register* methods is called\n * to register a dependency with Opium, it will be wrapped in this object, subsequent\n * calls to the inject method on it, will trigger the injection cycle.\n */\nexport default class Dependency {\n\n    /**\n     * Construct a dependency\n     *\n     * @param name - Name of the dependency\n     * @param dep - The dependency to be wrapped\n     * @param deps - An array of dependency names\n     * @param registry - The global dep registry\n     * @param injector - The injector to be used\n     * @param lifecycle - The lifecycle of the depepndency\n     */\n    constructor(name, dep, deps, registry, injector, lifecycle) {\n        this.name = name;\n        this.dep = dep;\n        this.registry = registry;\n        this.injector = injector;\n        this.lifecycle = lifecycle;\n\n        this.deps = deps;\n        this.injected = null;\n\n        if (this.deps && this.deps.filter((depName) => {return this.name === depName}).length) {\n            throw new Error(`Can't inject ${this.name} into ${this.name}`);\n        }\n    }\n\n    /**\n     * Perform the injection cycle according to the current dep lifecycle\n     *\n     * @returns {Dependency.injected|*} - Returns the result of performing the injection cycle\n     */\n    inject() {\n        if (!this.injected || this.lifecycle === PROTOTYPE) {\n            this.injected = this.injector.inject(this) || this.dep;\n        }\n\n        return this.injected;\n    }\n\n    /**\n     * Get an array of dependencies that this Dependency expects\n     *\n     * @returns {Array}\n     */\n    resolve() {\n        let dependencies = [];\n        if (this.deps) {\n            for (let name of this.deps) {\n                dependencies.push(this.registry.get(name));\n            }\n        }\n\n        return dependencies;\n    }\n}\n"],"sourceRoot":"/source/"}